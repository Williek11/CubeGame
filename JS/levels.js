const knowLevel = [true],

levels = {
    forLevels: {
        generic_enemy_nomove:(wE, hE, x) => {
            Game.entities.all.push({
                x: wE - x,
                y: hE,
                color: colors.entities.enemy.normal,
                del: false,
                width: 20,
                height: 20,
                update: function () {
                    Game.ctx.fillStyle = this.color;
                    Game.ctx.fillRect(map.refX + this.x, map.refY + this.y, 20, 20);
                    collide(this, () => {
                        if (player.events[0].on) {
                            this.del = true; this.color = colors.entities.enemy.hit;
                        }
                    });
                }
            })
        },
        generic_enemy_nomove_with_health:(wE, hE, x) => {
            Game.entities.all.push({
                x: wE - x,
                y: hE,
                color: colors.entities.enemy.normal,
                del: false,
                width: 20,
                height: 20,
                update: function () {
                    Game.ctx.fillStyle = this.color;
                    Game.ctx.fillRect(map.refX + this.x, map.refY + this.y, 20, 20);
                    collide(this, () => {
                        if (player.events[0].on) {
                            if(Math.floor(Math.random() * 6) === 2) {constructors.entity.bonus("health", this.x, this.y, 20, 20)}; this.del = true; this.color = colors.entities.enemy.hit;
                        }
                    });
                }
            })
        },
        generic_enemy_nomove_with_damage:(wE, hE, x, dmg) => {
            Game.entities.all.push({
                id: id.new(),
                x: wE - x,
                y: hE,
                color: colors.entities.enemy.normal,
                del: false,
                dmg: dmg,
                width: 20,
                height: 20,
                update: function () {
                    Game.ctx.fillStyle = this.color;
                    Game.ctx.fillRect(map.refX + this.x, map.refY + this.y, 20, 20);
                    collide(this, () => {
                        if (player.events[0].on) {
                            this.del = true; this.color = colors.entities.enemy.hit;
                        } else if(!player.noHit) {
                            player.onHit(this.dmg)
                        }
                    });
                }
            })
        },
        generic_enemy_move_with_damage:(wE, hE, x, sX, sY, chunk, dmg) => {
            Game.entities.all.push({
                id: id.new(),
                x: wE - x,
                y: hE,
                onHit:(dmg)=>{},
                chunkNmb: chunk,
                chunk: map.all[chunk],
                color: colors.entities.enemy.normal,
                del: false,
                dmg: dmg,
                sX: sX,
                sY: sY,
                width: 20,
                height: 20,
                update: function () {
                    Game.ctx.fillStyle = this.color;
                    let x = this.x, y = this.y, chunk = this.chunk, chunkX = chunk.x, chunkY = chunk.y;
                    Game.ctx.fillRect(map.refX + x, map.refY + y, 20, 20);
                    if (x < chunkX) { this.sX *= -1; x = chunkX } else if (x > chunkX + map.width - 20) { this.sX *= -1; x = chunkX + map.width - 20; };
                    if (y < chunkY) { this.sY *= -1; y = chunkY } else if (y > chunkY + map.height - 20) { this.sY *= -1; y = chunkY + map.height - 20; };
                    collide(this, () => {
                        if (player.events[0].on) {
                            this.del = true; this.color = colors.entities.enemy.hit;
                        } else if(!player.noHit) {
                            player.onHit(this.dmg)
                        }
                    });
                    this.x = x + this.sX;
                    this.y = y + this.sY;
                }
            })
        },
    },
    autoGenerated: [
        {
            name: "D",
            contents: () => {
                const wE = 400;const hE = 390;
                const random = ()=>{if(Math.round(Math.random()) === 1) {return (Math.random() * 10)} else {return (Math.random() * 10) * -1}};
                const n = (x)=>{constructors.entity.enemy("generic", 1, wE - x, hE, random(), random(), 20, 20, 0, 0)};
                for(var i=0;i<10000;i++){n(10)}
                const txt = (nmb, content) => { constructors.text(30, nmb, content); };
                txt(75, "Let me introduce you to the basics:");
                txt(60, "The most important principle is: when pressing shift, you can kill enemies and go faster.");
                txt(45, "Also, you can go faster pressing Shift. Anyway, when you kill all enemies in a level, you procced to the next.");
            },
            onload: ()=>{player.iX = 390;player.iY = 300;},
            onend: [()=>{Game.stop()},],
            grid: {
                width: 800, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
        {
            name: "D1",
            contents: () => {
                const wE = 400;const hE = 390;
                const random = ()=>{if(Math.round(Math.random()) === 1) {return (Math.random() * 10)} else {return (Math.random() * 10) * -1}};
                const n = (x)=>{constructors.entity.enemy("generic", 1, wE - x, hE, random(), random(), 20, 20, 0, 0)};
                for(var i=0;i<10000;i++){n(10)}
                const txt = (nmb, content) => { constructors.text(30, nmb, content); };
                txt(75, "Let me introduce you to the basics:");
                txt(60, "The most important principle is: when pressing shift, you can kill enemies and go faster.");
                txt(45, "Also, you can go faster pressing Shift. Anyway, when you kill all enemies in a level, you procced to the next.");
            },
            onload: ()=>{player.iX = 390;player.iY = 300;},
            onend: [()=>{Game.stop()},],
            grid: {
                width: 800, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,}, {x: 900, y: 0,}, {x: 1800, y: 0,}, {x: 2700, y: 0,}, {x: 3600, y: 0,}],
            },
        },
        {
            name: "1",
            contents: () => {
                const wE = 400;const hE = 390;
                const n = (x)=>{constructors.entity.enemy("nohealth", 1, wE - x, hE, 0, 0, 20, 20, 0, 0)};
                n(10); n(210); n(-190);
                const txt = (nmb, content) => { constructors.text(30, nmb, content); };
                txt(75, "Let me introduce you to the basics:");
                txt(60, "The most important principle is: when pressing shift, you can kill enemies and go faster.");
                txt(45, "Also, you can go faster pressing Shift. Anyway, when you kill all enemies in a level, you procced to the next.");
            },
            onload: ()=>{player.iX = 390;player.iY = 300;},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;const wE = 1700;const hE = 390;
                    const n = (x)=>{constructors.entity.enemy("generic", 1, wE - x, hE, 0, 0, 20, 20, 0, 1)};
                    n(10); n(110); n(-90); n(210); n(-190);
                    const txt = (nmb, content) => { constructors.text(30, nmb, content); };
                    Game.text.all = [];
                    txt(60, "Now, be introduced to enemies dropping health. 1/5 of the time they drop health, 4/5 of the time, nope!");
                    txt(45, "Try it with those dummies. Also, an interesting note is that you can pick the bonus even with full HP.");
                    Game.text.update();
                },
                ()=>{
                    Game.corridorsVisible = true;const wE = 3000;const hE = 390;const add = constructors.entity.enemy;
                    const n = (x, dmg)=>{add("nohealth", 1, wE - x, hE, 0, 0, 20, 20, dmg, 2)};
                    n(10, 2); n(160, 1); n(-150, 3);
                    const txt = (nmb, content) => { constructors.text(30, nmb, content); };
                    Game.text.all = [];
                    txt(75, "And now, the last concept you should be familiarized with (for now), damage!");
                    txt(60, "Enemies can do different damage. Try it with these dummies!");
                    txt(45, "Also, don't be scared. You regenerate!");
                    Game.text.update();
                    Game.tickEvents.push(()=>{if(player.health < 10 && knowLevel[0]) {knowLevel[0] = false;setTimeout(()=>{player.onHit(-1);knowLevel[0] = true},Game.tick * 40)}})
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "2",
            contents: () => {
                const add = constructors.entity.enemy;
                const n = (x)=>{add("generic", 1, 400 - x, 390, 5, 5, 20, 20, 1, 0)};
                n(10); n(210); n(-190);
            },
            onload: ()=>{player.iX = 390;player.iY = 300;},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;let hE = 360;const add = constructors.entity.enemy;
                    const n = (x)=>{add("generic", 1, 1700 - x, hE, 5, 5, 20, 20, 1, 1)};
                    n(10); n(110); n(-90); n(210); n(-190);
                    hE = 420;
                    n(10); n(110); n(-90); n(210); n(-190);
                },
                ()=>{
                    Game.corridorsVisible = true;
                    const rng = Math.random; const round = Math.round;const add = constructors.entity.enemy;
                    const random = ()=>{if(round(rng()) === 0) {return rng() * 10} else {return -rng() * 10}};
                    const n = ()=>{add("generic", 1, 3000 - 10, 390, random(), random(), 20, 20, 1, 2)};
                    for(var i=0;i<10;i++){n()}
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "3",
            contents: () => {
                let wE = 400, hE = 390;
                const newB = constructors.entity.projectile;
                const n = (x)=>{newB("bullet", wE - x, hE, 1, 1, 20, 20, 1, 0)};
                n(10); n(110); n(-90);
                hE = 490;
                n(10); n(110); n(-90);
                hE = 290;
                n(10); n(110); n(-90);
            },
            onload: ()=>{player.iX = 390;player.iY = 100;},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;let wE = 1700, hE = 390;
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = (x)=>{add(wE, hE, x, 5, 5, 1, 1)};
                    n(10); n(110); n(-90);
                    hE = 490;
                    n(10); n(110); n(-90);
                    hE = 290;
                    n(10); n(110); n(-90);
                    Game.tickEvents.push(()=>{if(Game.ticksPassed % 100 === 0) {
                        const newB = constructors.entity.projectile; const rng = Math.random; const round = Math.round;
                        const random = ()=>{if(round(rng()) === 1) {return rng() * 10} else {return -rng() * 10}};
                        for(var i = 0, a = Game.entities.all, l = a.length;i < l;i++) {if(a[i].type === undefined){newB("bullet", a[i].x, a[i].y, random(), random(), 20, 20, 1, a[i].chunkNmb);}}
                    }})
                },
                ()=>{
                    Game.corridorsVisible = true;let wE = 3000, hE = 390;
                    const round = Math.round; const rng = Math.random;
                    const random = ()=>{if(round(rng()) === 0) {return rng() * 10} else {return -rng() * 10}};
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = ()=>{add(wE, hE, 10, random(), random(), 2, 1)};
                    n(); n(); n(); n(); n(); n(); n(); n(); n(); n();
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "4",
            contents: () => {
                let wE = 400, hE = 390;
                const newM = constructors.entity.projectile;
                const n = (x)=>{newM("missile", wE - x, hE, 1, 1, 20, 20, 1, 0)};
                n(10); n(110); n(-90);
                hE = 490;
                n(10); n(110); n(-90);
                hE = 290;
                n(10); n(110); n(-90);
            },
            onload: ()=>{player.iX = 390;player.iY = 100;},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;let wE = 1700, hE = 390;
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = (x)=>{add(wE, hE, x, 5, 5, 1, 1)};
                    n(10); n(110); n(-90);
                    hE = 490;
                    n(10); n(110); n(-90);
                    hE = 290;
                    n(10); n(110); n(-90);
                    Game.tickEvents.push(()=>{if(Game.ticksPassed % 250 === 0) {
                        const newM = constructors.entity.projectile; const rng = Math.random; const round = Math.round;
                        const random = ()=>{if(round(rng()) === 1) {return rng() * 10} else {return -rng() * 10}};
                        for(var i = 0, a = Game.entities.all, l = a.length;i < l;i++) {if(a[i].type === undefined){newM("missile", a[i].x, a[i].y, random(), random(), 20, 20, 1, a[i].chunkNmb);}}
                    }})
                },
                ()=>{
                    Game.corridorsVisible = true;let wE = 3000, hE = 390;
                    const round = Math.round; const rng = Math.random;
                    const random = ()=>{if(round(rng()) === 0) {return rng() * 10} else {return -rng() * 10}};
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = ()=>{add(wE, hE, 10, random(), random(), 2, 1)};
                    n(); n(); n(); n(); n(); n(); n(); n(); n(); n();
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "5",
            contents: () => {
                let wE = 400, hE = 390;
                const newS = constructors.entity.bonusMove;
                const n = (x)=>{newS("slow", wE - x, hE, 1, 1, 20, 20, 0, undefined)};
                n(10);
            },
            onload: ()=>{player.iX = 390;player.iY = 100;},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;let wE = 1700, hE = 390;
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = (x)=>{add(wE, hE, x, 5, 5, 1, 1)};
                    n(10); n(110); n(-90);
                    hE = 490;
                    n(10); n(110); n(-90);
                    hE = 290;
                    n(10); n(110); n(-90);
                    Game.tickEvents.push(()=>{if(Game.ticksPassed % 150 === 0) {
                        const newS = constructors.entity.bonusMove; const rng = Math.random; const round = Math.round;
                        const random = ()=>{if(round(rng()) === 1) {return rng() * 10} else {return -rng() * 10}};
                        for(var i = 0, a = Game.entities.all, l = a.length;i < l;i++) {if(a[i].type === undefined){a[i].color = colors.entities.enemy.highLight; newS("slow", a[i].x, a[i].y, random(), random(), 20, 20, a[i].chunkNmb, a[i].id);break}}
                    }})
                },
                ()=>{
                    Game.corridorsVisible = true;let wE = 3000, hE = 390;
                    const round = Math.round; const rng = Math.random;
                    const random = ()=>{if(round(rng()) === 0) {return rng() * 10} else {return -rng() * 10}};
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = ()=>{add(wE, hE, 10, random(), random(), 2, 1)};
                    n(); n(); n(); n(); n(); n(); n(); n(); n(); n();
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "B",
            contents: () => {
                constructors.entity.enemy("boss1", 15, 725, 400, 5, 5, 50, 50, 2, 0);
            },
            onload: ()=>{player.iX = 740;player.iY = 200;},
            onend: [
                ()=>{Game.stop()},
            ],
            grid: {
                width: 1500, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
        {
            name: "6",
            contents: () => {
                constructors.entity.enemy("generic", 1, 390, 400, 0, 0, 20, 20, 1, 0);
                constructors.entity.projectile("guidedbullet", 0, 0, 3, 3, 20, 20, 1, 0);
            },
            onload: ()=>{player.iX=390;player.iY = 100},
            onend: [
                ()=>{
                    Game.corridorsVisible = true;let wE = 1700, hE = 390;
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = (x)=>{add(wE, hE, x, 5, 5, 1, 1)};
                    n(10); n(110); n(-90);
                    hE = 490;
                    n(10); n(110); n(-90);
                    hE = 290;
                    n(10); n(110); n(-90);
                    Game.tickEvents.push(()=>{if(Game.ticksPassed % 150 === 0) {
                        const newS = constructors.entity.projectile; const rng = Math.random;
                        const random = ()=>{return 2 + rng() * 2};
                        for(var i = 0, a = Game.entities.all, l = a.length;i < l;i++) {if(a[i].type === undefined){
                            a[i].color = colors.entities.enemy.highLight; newS("guidedbullet", a[i].x, a[i].y, random(), random(), 20, 20, 1, a[i].chunkNmb);break}
                        }
                    }})
                },
                ()=>{
                    Game.corridorsVisible = true;let wE = 3000, hE = 390;
                    const rng = Math.random;
                    const random = ()=>{return 1 + rng() * 5};
                    const add = levels.forLevels.generic_enemy_move_with_damage;
                    const n = ()=>{add(wE, hE, 10, random(), random(), 2, 1)};
                    n(); n(); n(); n(); n(); n(); n(); n(); n(); n();
                },
                ()=>{Game.stop()},
            ],
            grid: {
                width: 800, height: 800,
                corridor: [{x:800, y:375, width:500, height:50,}, {x:2100, y:375, width:500, height:50,},],
                all: [{x: 0, y: 0,}, {x: 1300, y: 0,}, {x: 2600, y: 0,},],
            },
        },
        {
            name: "B",
            contents: () => {
                constructors.entity.enemy("boss1", 15, 725, 400, 5, 5, 50, 50, 2, 0);
            },
            onload: ()=>{player.iX = 740;player.iY = 200;},
            onend: [
                ()=>{Game.stop()},
            ],
            grid: {
                width: 1500, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
        {
            name: "B",
            contents: () => {
                constructors.entity.enemy("boss1", 15, 725, 400, 5, 5, 50, 50, 2, 0);
            },
            onload: ()=>{player.iX = 740;player.iY = 200;},
            onend: [
                ()=>{Game.stop()},
            ],
            grid: {
                width: 1500, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
        {
            name: "B",
            contents: () => {
                constructors.entity.enemy("boss1", 15, 725, 400, 5, 5, 50, 50, 2, 0);
            },
            onload: ()=>{player.iX = 740;player.iY = 200;},
            onend: [
                ()=>{Game.stop()},
            ],
            grid: {
                width: 1500, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
        {
            name: "B",
            contents: () => {
                constructors.entity.enemy("boss1", 15, 725, 400, 5, 5, 50, 50, 2, 0);
            },
            onload: ()=>{player.iX = 740;player.iY = 200;},
            onend: [
                ()=>{Game.stop()},
            ],
            grid: {
                width: 1500, height: 800,
                corridor: [,],
                all: [{x: 0, y: 0,},],
            },
        },
    ],
    updateMenu: ()=>{
        const DOM = $D[1]("theLevels");
        DOM.innerHTML="";
        let bossLevel = 0;
        let i = 0;
        let l = levels.autoGenerated.length;
        let width;
        const rng = Math.random;
        const nT = ()=>{return 125 + rng() * 300};
        const n = (b) => {
            var newDOM = document.createElement("div"), random = 3 + rng() * 7;
            let nL = 100 + b * 150;
            width = b * 150 + 200;
            let isIt = bossLevel === maxBossLevel;
            newDOM.style = "position:absolute;left:" + nL + "px;top:" + nT() + "px;";
            newDOM.addEventListener("click", () => { Game.start(b); if (isIt) {console.log(isIt);theLastBossLevel = true;} else {theLastBossLevel = false} });
            newDOM.innerHTML = '<div class="levelCircle" style="animation:upDown infinite '+random+'s">'+levels.autoGenerated[b].name+'</div>';
            DOM.appendChild(newDOM);
            if(levels.autoGenerated[b].name === "B") {
                if (bossLevel === maxBossLevel) {i = l;}
                else {bossLevel++}
            };
        }
        let scroll = document.createElement("div");
        for(;i < l;i++) {n(i)};
        scroll.style = 'width:'+width+'px;height:0.1px';
        DOM.appendChild(scroll);
    },
};