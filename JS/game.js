/**************/
/**** Game ****/
/**************/

let intervalStart
let intervalMapUpdate

const Game = {
    load: (url)=>{
        var js=document.createElement('script');
        js.setAttribute('type','text/javascript');
        js.setAttribute('id','modscript_'+id);
        js.setAttribute('src',url);
        document.head.appendChild(js);
        console.log('Loaded');
    },
    eventsInterpretor: (i) => {
        const event = player.events[i]
        if(Game.keys[event.key]) {if(event.condition() === true) {event.whenHappen()} else {event.whenNo()}}
    },
    cursor: {
        x:0,
        y:0,
        mapX:0,
        mapY:0,
        events: {
            hover: [],
            click: [],
        }
    },
    corridorsVisible: false,
    onEndEvent: 0,
    ticksPassed: 0,
    sure: true,
    keys: {},
    canvas: $D[1]("canvas"),
    ctx: $D[1]("canvas").getContext("2d"),
    tick: 20,
    tickEvents: [],
    debugAccess: false,
    cooldowns: {
        dash: {
            active: false,
            decrease: 100 / 70,
            currentHeight: 100,
            update: function () {
                const height = this.currentHeight - this.decrease;
                this.currentHeight = height;
                document.getElementById("dashFill").style.height = height + "%";
                if (height < 0) { this.currentHeight = 100;this.active = false;document.getElementById("dashBorder").style="";document.getElementById("dashBackground").style="" };
            }
        },
        speed: {
            active: false,
            decrease: 100 / 200,
            currentHeight: 100,
            update: function () {
                const height = this.currentHeight - this.decrease;
                this.currentHeight = height;
                document.getElementById("speedFill").style.height = height + "%";
                if (height < 0) { this.currentHeight = 100; this.active = false; document.getElementById("speedBackground").style=""; document.getElementById("speedBorder").style=""; };
            }
        }
    },
    stop: ()=>{
        clearInterval(intervalStart);
        Game.cursor.events.hover = [];
        Game.ticksPassed = 0;
        const gam = $D[1]("game");
        gam.style.animation = "disappear 1 1s";
        const a = "animation:appear 1 1s;display:block"
        $D[1]("levelSelector").style = a;
        $D[1]("back").style = a
        Game.text.all = []
        Game.tickEvents = []
        player.sX = 0;
        player.sY = 0;
        if(theLastBossLevel) {maxBossLevel++;levels.updateMenu();localStorage.bossLevel = maxBossLevel}
        setTimeout(() => { gam.style = "display:none"; }, 900)},
    resize:()=>{
        Game.canvas.width = window.innerWidth;
        Game.canvas.height = window.innerHeight;
        const GCEHL = Game.cursor.events.hover.length;
        if (GCEHL > -1) {
            const all = Game.cursor.events.hover;
            for (var i = 0; i < GCEHL; i++) {
                all[i].onResize()
            }
        }
    },
    updateScreen: ()=>{
        intervalMapUpdate = setInterval(()=>{
            const ctx = Game.ctx
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.fillStyle = colors.HTML.game.gridLevel

            const mapX = window.innerWidth / 2 + Game.cursor.mapX;
            const mapY = window.innerHeight / 2 + Game.cursor.mapY;
            map.x = mapX;
            map.y = mapY;
            const refX = mapX - player.x - player.width / 2;
            const refY = mapY - player.y - player.height / 2;
            map.refX = refX;
            map.refY = refY;
            ctx.fillRect(refX, refY, map.width, map.height);
            let containers = levels.autoGenerated[Game.index].grid.all;

            for (let i = 0, l = containers.length;i < l;i++) {
                let SubI = containers[i];
                ctx.fillRect(refX + SubI.x, refY + SubI.y, map.width, map.height);
            };

            for(var i = 0,a = Game.entities.all, l = a.length;i < l;i++) {
                const subject = a[i]
                ctx.fillStyle = subject.color;
                ctx.fillRect(refX + subject.x, refY + subject.y, subject.width, subject.height);
            };

            ctx.fillStyle = player.color;
            ctx.fillRect(map.x - player.width / 2, map.y - player.height / 2, player.width, player.height);
        }, Game.tick)
    },
    update: ()=>{
        if (Game.entities.all.length > 0) {
            
            for (let GEA = Game.entities.all, i = GEA.length - 1; i >= 0; i--) { if (GEA[i].del) { GEA.splice(i, 1) } };
            for (let i = 0, a = Game.tickEvents, l = a.length;i < l; i++) { a[i]() }
            for (let i = 0, l = player.events.length; i < l; i++) { Game.eventsInterpretor(i) };

            Game.ticksPassed++;
            if(Game.cooldowns.dash.active) Game.cooldowns.dash.update();
            if(Game.cooldowns.speed.active) Game.cooldowns.speed.update();

            const ctx = Game.ctx;
            const wIW=window.innerWidth;const wIH=window.innerHeight;
            ctx.clearRect(0, 0, wIW, wIH);

            const mapX = wIW / 2 + Game.cursor.mapX;
            const mapY = wIH / 2 + Game.cursor.mapY;
            map.x = mapX;
            map.y = mapY;
            const refX = mapX - player.x - player.width / 2;
            const refY = mapY - player.y - player.height / 2;
            map.refX = refX;
            map.refY = refY;

            const containers = map.all; const lContainer = containers.length;
            ctx.fillStyle = colors.HTML.game.gridLevel;
            for (let i = 0;i < lContainer;i++) {
                const SubI = containers[i]
                ctx.fillRect(refX + SubI.x, refY + SubI.y, map.width, map.height)
            };

            for(let i = 0, l = Game.entities.all.length;i < l;i++) {Game.entities.all[i].update()};

            ctx.fillStyle = "#2e234eaa";
            const margin = 40;const scaled = 16;
            for(let i = 0;i < lContainer;i++) {
                const SubI = containers[i];
                ctx.fillRect(margin + SubI.x / scaled, margin + SubI.y / scaled, map.width / scaled, map.height / scaled)
            };

            if (Game.corridorsVisible) {
                ctx.fillStyle = colors.HTML.game.gridLevel;
                let subject = levels.autoGenerated[Game.index].grid.corridor[player.currentChunkNumber];const subX=subject.x;const subY=subject.y;const subW=subject.width;const subH=subject.width;
                ctx.fillRect(refX + subX, refY + subY, subW, subH);
                ctx.fillStyle = "#2e234eaa";
                ctx.fillRect(margin + subX / scaled, margin + subY / scaled - (player.height / 4), subW / scaled, subH / (scaled / 4));
            }

            player.update();
        } else {
            levels.autoGenerated[Game.index].onend[Game.onEndEvent]();
            Game.onEndEvent++;
        }
    },
    entities: {
        all:[],
        add: ()=>{},
        idChoose: 0,
    },
    text: {
        all:[],
        fontFamily: "Oxanium",
        fontSize: "15px",
        update: () => {
            const additionalText = $D[1]("additionalText");
            additionalText.innerHTML = "";
            for (let i = 0, l = Game.text.all.length; i < l; i++) {
                additionalText.innerHTML += `<div style="font-weight: 100 !important;color:${colors.HTML.game.text};font-size:${Game.text.all[i].size};font-family:Oxanium;position:absolute;left:${Game.text.all[i].x + "px"};bottom:${Game.text.all[i].y + "px"}">${Game.text.all[i].content}</div>`;
            };
        }
    },
    restart: ()=>{
        Game.stop();
    },
    start: (i)=>{
        player.currentChunkNumber = 0;
        Game.corridorsVisible = false;
        player.color = colors.entities.player;
        map.update(i);
        player.chunk = map.all[0];
        Game.index = i;
        Game.onEndEvent = 0;
        constructors.mouseEventHover(
            "LifeHover",
            window.innerWidth - 100,
            window.innerHeight - 100,
            75,
            75,
            ()=>{$D[1]("healthInformation").style.display = "block"},
            ()=>{$D[1]("healthInformation").style="";},
            function(){this.x=window.innerWidth - 100,this.y=window.innerHeight - 100}
        )

        if(levels.autoGenerated[i].onload !== undefined) {levels.autoGenerated[i].onload()};
        if(levels.autoGenerated[i].perTick !== undefined) {Game.tickEvents.push(levels.autoGenerated[i].perTick)};

        player.x = player.iX;
        player.y = player.iY;
        player.health = player.totalHealth;
        $D[1]("healthFill").style.transform = "translateY(-51px)";
        $D[1]("health").innerHTML=`You have ${player.health} points of health of a total of ${player.totalHealth}.`;
        Game.entities.all=[];
        const levelS = $D[1]("levelSelector");
        levelS.style.animation = "disappear 1 1s";
        const buttonBack = $D[1]("back");
        buttonBack.style.animation = "disappear 1 1s";
        const gam = $D[1]("game");
        gam.style = "animation:appear 1 1s;display:block";
        Game.resize();
        map.contents();
        for(let i = 0, l = Game.entities.all.length;i < l;i++) {Game.entities.all[i].update()};
        
        const ctx = Game.ctx;
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

        ctx.fillStyle = colors.HTML.game.gridLevel;

        const mapX = window.innerWidth / 2 + Game.cursor.mapX;
        const mapY = window.innerHeight / 2 + Game.cursor.mapY;
        map.x = mapX;
        map.y = mapY;
        const refX = mapX - player.x - player.width / 2;
        const refY = mapY - player.y - player.height / 2;
        map.refX = refX;
        map.refY = refY;
        const containers = map.all;

        ctx.fillStyle = colors.HTML.game.gridLevel;

        let l = containers.length;

        for (let i = 0; i < l; i++) {
            const SubI = containers[i]
            ctx.fillRect(refX + SubI.x, refY + SubI.y, map.width, map.height)
        };

        for (let i = 0, a = Game.entities.all, l = a.length; i < l; i++) {
            e = a[i];
            ctx.fillRect(refX + e.x, refY + e.y, e.width, e.height);
        }

        ctx.fillRect(map.x - player.width / 2, map.y - player.height / 2, player.width, player.height);

        Game.text.update();

        Game.updateScreen();

        setTimeout(()=>{
            levelS.style = "display:none";
            buttonBack.style = "display:none";
            setTimeout(()=>{intervalStart = setInterval(Game.update,Game.tick);clearInterval(intervalMapUpdate)},200);
        },900)
        Game.text.update();
    },
}

$D[1]("exitLevel").addEventListener("click",()=>{clearInterval(intervalStart)
    Game.ticksPassed = 0;
    const gam = $D[1]("game");
    gam.style.animation = "disappear 1 1s";
    const a = "animation:appear 1 1s;display:block";
    $D[1]("levelSelector").style = a;
    $D[1]("back").style = a;
    Game.text.all = [];
    Game.tickEvents = [];
    setTimeout(() => { gam.style = "display:none"; }, 900);
})

levels.updateMenu();
window.addEventListener("resize", ()=>{Game.resize();Game.update()});
window.addEventListener("keydown", (e) => { Game.keys[e.key] = true });
window.addEventListener("keyup", (e) => { Game.keys[e.key] = false });
window.addEventListener("mousemove", (e) => {
    const cursorX = e.clientX;
    const cursorY = e.clientY;
    Game.cursor.x = cursorX;
    Game.cursor.y = cursorY;
    Game.cursor.mapX = ((window.innerWidth + player.width) / 2 - e.clientX) / 7;
    Game.cursor.mapY = ((window.innerHeight + player.height) - cursorY) / 7;
    const GCEHL = Game.cursor.events.hover.length;
    if(GCEHL > -1) {
        const all = Game.cursor.events.hover;
        for(var i = 0; i < GCEHL;i++) {
            const sub = all[i];
            if (cursorX <= sub.x + sub.width && sub.x <= cursorX && cursorY <= sub.y + sub.height && sub.y <= cursorY) {
                if(!sub.active) {sub.onEvent();sub.active = true;}
            } else if (sub.active) {
                sub.onStop();
                sub.active = false;
            }
        }
    }
})