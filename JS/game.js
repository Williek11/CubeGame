/**************/
/**** Game ****/
/**************/

let intervalStart
let intervalMapUpdate

const game = {
    eventsInterpretor: (i) => {
        const event = player.events[i]
        if(game.keys[event.key]) {if(event.condition() === true) {event.whenHappen()} else {event.whenNo()}}
    },
    cursor: {
        x:0,
        y:0,
    },
    corridorsVisible: false,
    onEndEvent: 0,
    ticksPassed: 0,
    sure: true,
    keys: {},
    canvas: $D[1]("canvas"),
    ctx: $D[1]("canvas").getContext("2d"),
    tick: 25,
    tickEvents: [],
    debugAccess: false,
    stop: ()=>{
        clearInterval(intervalStart)
        game.ticksPassed = 0
        const gam = $D[1]("game");
        gam.style.animation = "disappear 1 1s";
        const a = "animation:appear 1 1s;display:block"
        $D[1]("levelSelector").style = a;
        $D[1]("back").style = a
        game.text.all = []
        game.tickEvents = []
        setTimeout(() => { gam.style = "display:none"; }, 900)},
    resize:()=>{
        game.canvas.width = window.innerWidth;
        game.canvas.height = window.innerHeight;
    },
    updateScreen: ()=>{
        intervalMapUpdate = setInterval(()=>{
            const ctx = game.ctx
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.fillStyle = colors.HTML.game.gridLevel

            const mapX = window.innerWidth / 2 + game.cursor.x;
            const mapY = window.innerHeight / 2 + game.cursor.y;
            map.x = mapX;
            map.y = mapY;
            const refX = mapX - player.x - player.width / 2;
            const refY = mapY - player.y - player.height / 2;
            map.refX = refX;
            map.refY = refY;
            ctx.fillRect(refX, refY, map.width, map.height);
            let containers = levels.autoGenerated[game.index].grid.all;

            for (let i = 0, l = containers.length;i < l;i++) {
                let SubI = containers[i]
                ctx.fillRect(refX + SubI.x, refY + SubI.y, map.width, map.height)
            };

            for(var i = 0,a = game.entities.all, l = a.length;i < l;i++) {
                const subject = a[i]
                ctx.fillStyle = subject.color
                ctx.fillRect(map.refX + subject.x, map.refY + subject.y, subject.width, subject.height)
            };

            ctx.fillStyle = player.color;
            ctx.fillRect(map.x - player.width / 2, map.y - player.height / 2, player.width, player.height);
        }, game.tick)
    },
    update: ()=>{
        if (game.entities.all.length > 0) {

            if (game.ticksPassed % 5 === 0) {
                for (let GEA = game.entities.all, i = GEA.length - 1; i >= 0; i--) { if (GEA[i].del) { GEA.splice(i, 1) } };
                const keys = game.keys;
                if (keys["Alt"]) {
                    if(keys["F12"]) {
                        if(!game.debugAccess) {
                            console.log("Debug Console Granted");
                            game.debugAccess = true;
                        } else {
                            console.log("Debug Console Revoked");
                            game.debugAccess = false;
                        }
                    }
                }
            }

            for (let i = 0, a = game.tickEvents, l = a.length;i < l; i++) { a[i]() }
            for (let i = 0, l = player.events.length; i < l; i++) { game.eventsInterpretor(i) };

            game.ticksPassed++

            const ctx = game.ctx;
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

            ctx.fillStyle = colors.HTML.game.gridLevel

            const mapX = window.innerWidth / 2 + game.cursor.x;
            const mapY = window.innerHeight / 2 + game.cursor.y;
            map.x = mapX;
            map.y = mapY;
            const refX = mapX - player.x - player.width / 2;
            const refY = mapY - player.y - player.height / 2;
            map.refX = refX;
            map.refY = refY;
            const containers = map.all;
            const margin = 40;
            const scaled = 16;
            
            ctx.fillStyle = colors.HTML.game.gridLevel

            let l = containers.length;

            for (let i = 0;i < l;i++) {
                const SubI = containers[i]
                ctx.fillRect(refX + SubI.x, refY + SubI.y, map.width, map.height)
            };

            ctx.fillStyle = "#444444aa"
            for(let i = 0;i < l;i++) {
                const SubI = containers[i]
                ctx.fillRect(margin + SubI.x / scaled, margin + SubI.y / scaled, map.width / scaled, map.height / scaled)
            };

            if (game.corridorsVisible) {
                let subject = levels.autoGenerated[game.index].grid.corridor[player.chunk]
                ctx.fillStyle = colors.HTML.game.gridLevel
                ctx.fillRect(refX + subject.x, refY + subject.y, subject.width, subject.height)
                ctx.fillStyle = "#444444aa"
                ctx.fillRect(margin + subject.x / scaled, margin + subject.y / scaled - (player.height / 4), subject.width / scaled, subject.height / (scaled / 4))
            }

            game.entities.update();
            player.update();
        } else {
            levels.autoGenerated[game.index].onend[game.onEndEvent]();
            game.onEndEvent++;
        }
    },
    entities: {
        all:[],
        idChoose: 0,
        update: ()=>{for(let i = 0, l = game.entities.all.length;i < l;i++) {game.entities.all[i].update()}},
    },
    text: {
        all:[],
        update: () => {
            const additionalText = $D[1]("additionalText");
            additionalText.innerHTML = "";
            for (let i = 0, l = game.text.all.length; i < l; i++) {
                additionalText.innerHTML += `<div style="font-weight: 100 !important;color:${colors.HTML.game.text};font-size:${game.text.all[i].size};font-family:Oxanium;position:absolute;left:${game.text.all[i].x + "px"};bottom:${game.text.all[i].y + "px"}">${game.text.all[i].content}</div>`;
            }
        }
    },
    restart: ()=>{
        game.stop()
    },
    start: (i)=>{
        player.color = colors.entities.player
        map.update(i)
        game.index = i
        game.onEndEvent = 0

        if(levels.autoGenerated[i].onload !== undefined) {levels.autoGenerated[i].onload()}
        if(levels.autoGenerated[i].perTick !== undefined) {game.tickEvents.push(levels.autoGenerated[i].perTick)}

        player.x = player.iX;
        player.y = player.iY;
        player.chunk = 0;
        player.sX = 0;
        player.sY = 0;
        player.health = 10;
        $D[1]("health").innerHTML=`You have ${player.health} points of health.`;
        game.entities.all=[];
        const levelS = $D[1]("levelSelector");
        levelS.style.animation = "disappear 1 1s";
        const buttonBack = $D[1]("back");
        buttonBack.style.animation = "disappear 1 1s";
        const gam = $D[1]("game");
        gam.style = "animation:appear 1 1s;display:block";
        game.resize();
        map.contents();
        game.update();
        game.text.update()

        game.updateScreen()

        setTimeout(()=>{
            levelS.style = "display:none";
            buttonBack.style = "display:none";
            setTimeout(()=>{intervalStart = setInterval(game.update,game.tick);clearInterval(intervalMapUpdate)},200);
        },900)
        if (game.sure) {
            window.addEventListener("resize", ()=>{game.resize();game.update()});
            window.addEventListener("keydown", (e) => { game.keys[e.key] = true });
            window.addEventListener("keyup", (e) => { game.keys[e.key] = false });
            window.addEventListener("mousemove", (e) => {
                game.cursor.x = ((window.innerWidth + player.width) / 2 - e.clientX) / 7;
                game.cursor.y = ((window.innerHeight + player.height) - e.clientY) / 7
            })
            game.sure = false
        }
        game.text.update()
    },
}

$D[1]("exitLevel").addEventListener("click",()=>{clearInterval(intervalStart)
    game.ticksPassed = 0
    const gam = $D[1]("game");
    gam.style.animation = "disappear 1 1s";
    const a = "animation:appear 1 1s;display:block"
    $D[1]("levelSelector").style = a;
    $D[1]("back").style = a
    game.text.all = []
    game.tickEvents = []
    setTimeout(() => { gam.style = "display:none"; }, 900)
})
levels.updateMenu();